
TODO:
	Change behavior of 'v' to use preset window layouts. eg, '1v'
	should make one window visible, while (perhaps):
	2v -> "0.5x1.0@0,0; 0.5x1.0@0.5,0"  (2 screens, top and bottom)
	3v -> "1.0x0.5@0,0; 0.5x0.5@0,0.5; 0.5x0.5@0.5,0.5"
	4v -> "1.0x0.5@0,0; 0.34x0.5@0,0.5; 0.33x0.5@0.34,0.5; 0.33x0.5@0.37,0.5"
	5v -> "1.0x0.5@0,0; 1.0x0.5@0,0.5"  (2 screens, left and right)
	6v -> "0.5x1.0@0,0; 0.5x0.5@0.5,0; 0.5x0.5@0.5,0.5"
	7v -> "0.5x1.0@0,0; 0.5x0.34@0.5,0; 0.5x0.33@0.5,0.34; 0.5x0.33@0.5,0.37"
	8v -> "0.5x0.5@0,0; 0.5x0.5@0,0.5; 0.5x0.5@0.5,0; 0.5x0.5@0.5,0.5"
	Perhaps implement 's' to save the current layout into a buffer.  Make
	the presets modifiable at startup.

	Need to have a pool of ttys and a pool of windows (maybe just use
	the existing tree and set split_point = 1.0 to hide unused)
	Be able to manipulate them.

	Change name of reshape_window.  Reshape_window should only
	reshape the window, and not the underlying pty.  As I write this,
	passing 'w' in the arg string makes the function change the pty width,
	but we probably need a distinct function with a better name.

	Implement an "insert mode".  That is, have a command from command mode
	that sets the keybinding so that all keys except 'return/enter' are
	passed through, and return is bound to transition to command mode.
	This would allow the user to easily enter one line of text to the tty.

	In full-screen mode, make hjkl scroll the pty.

	Make it easy to swap bindings.  eg, so that hjkl could be used for
	scrolling in non-full screen mode.  Maybe have labelled bindings,
	so perhaps 'a or 'b would select binding a or b.  Would be simpler
	to use numbers, so 1B or 2B could select bindings 1 or 2.  It seems
	hjkl would be better for scrolling than <> and fb

	Copy-mode, with stack of registers and ability to edit.
	Or, maybe just have a binding (s) that dumps the current content
	of the scrollback region to a file like ~/.smtx-pid-timestamp
	Perhaps use (e) to edit the file (eg, spawn $EDITOR), then (p)
	to paste it.

	Ability to set titles.

	List all windows with titles, with ability to navigate.

	Figure out initialization.  Maybe just use a "source" command to read
	from a file.  One could specify a fifo and inject it into the main
	processing loop so the fifo gets selected in the main loop allowing
	one to send arbitrary keystrokes.  Clearly, there are security issues.

BUGS:
	Make tput rep work.  eg, tput rep w 5 should write 5 'w' to term,
	but the parameters do not seem to be getting sent properly.  We get
	argc == 1 and argv[0] == 5 - 1, but the w is chomped.  Note that this
	is the only terminfo entry that uses %c, and I suspect there is a bug
	in vtparser

	Figure out why I am getting an extra line at the bottom of screen in
	termux.  Note this happens outside of smtx, so it is not our bug to
	fix, but may be a terminfo issue.  It needs to be understood.

	As of 61c41fe0f1dd73829315c959b69cf44df2af102f, the test suite hangs
	on macos

MAYBE TODO:
	Register signal handlers for TERM and HUP.  Need to ensure
	that endwin is called.

	Be able to attach a process to multiple windows.
	Configure bindings from a startup file or ?
	Multi-key bindings (?)
	Pass master fd of a pty through a socket.

Partially implemented/vague ideas:
	Implement decent error reporting.

	Be able to set tty screen width. Eg, perhaps 'w' to set width of the
	focused window, and `W` to change the tty.  Then +/- to adjust
	width of window, and maybe </> to adjust width of tty.  Or </>
	should scroll the window.  But +/- should also change number
	of rows in a type 0 canvas.  Need to think about this, but defintely
	want ability to change tty width.  Probably use one binding in which
	hjkl navigate windows, one in which hjkl grows windows, and one in
	which hjkl changes scroll in pty.  Also use <tab> to scroll right
	one tabstop in the pty.

	Needs to be easier to navigate in full screen mode.   Perhaps
	title bar would show title of windows above, below, to the
	left, and right.  Then hjkl navigation would stay in full
	screen mode while going between them.
